# 트리

## 정의

* 한 개 이상의 노드로 이루어진 유한 집합



## 구성

* 노드(정점)과 간선으로 이루어짐
  * 시작 노드를 루트라고 함
* 정점의 수 - 1 = 간선의 수



## 이진 트리

* 모든 노드들이 2개의 서브트리를 갖는 트리
* 각 노드가 최대 2개의 자식 노드를 가질 수 있음



## 순회

* 트리에 특화된 탐색 방법
* 트리의 각 노드를 중복되지 않게 전부 방문하는것을 말함

### 전위순회

> 부모노드 방문 후 자식노드를 좌, 우 순서로 방문

* 현재 노드 n을 방문하여 처리

* 왼쪽 서브트리 이동, 오른쪽 서브트리로 이동

* ```python
  def preorder_traverse(T):
      if T:
          visit(T)
          preorder_traverse(T.left)
          preorder_traverse(T.right)
  ```





### 중위순회

> 왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순

* 왼쪽 노드 방문 후 자기 자신 처리

* ```python
  def indorder_traverse(T):
      if T:
          inorder_traverse(T.left)
          visit(T)
          inorder_traverse(T.right)
  ```





### 후위순회

> 자식노드를 좌, 우 순서로 방문한 후 부모노드로 방문

* ```python
  def postorder_traverse(T):
      if T:
          postorder_traverse(T.left)
          postorder_traverse(T.right)
          visit(T)
  ```

* root 가 가장 마지막에 처리됨



## 표현

### 배열

* 0번 인덱스는 비워놓고 사용

* 노드 번호가 i인 노드의 부모 노드 : i//2
* 왼쪽 자식 : 2\*i, 오른쪽 자식 : 2*i + 1

#### 문제 풀이를 위한 저장 방법

* 부모의 번호를 인덱스로 갖는 2개의 리스트 사용

* ```python
  # input : 1 2 1 3 3 4 3 5
  N = E + 1	# 정점 수 = 엣지 수 + 1
  
  c1 = [0]*(N+1)
  c2 = [0]*(N+1)
  for i in range(E)
  	p, c = arr[2*i], arr[2*i + 1]
      if c1[p] == 0:
          c1[p] = c
      else:
          c2[p] = c
  ```

* 포화이진트리가 아닌 경우 꼭 1번 노드가 루트라는 보장은 없다



### 연결 리스트

* [L 자식 위치, 노드 정보, R 자식 위치]



## 수식 트리

> 수식을 표현하는 이진 트리

* 연산자는 루트 노드이거나 가지 노드
* 피연산자는 모두 잎 노드



## 이진 탐색 트리

* 탐색작업을 효율적으로 하기 위한 자료구조
* 모든 원소는 서로 다른 키를 가짐



### 탐색연산

* 루트에서 시작한다
* 탐색할 키 값을 루트 노드의 키 값과 비교한다
  * 키 값이 루트보다 작으면 왼쪽 서브트리에 대해서
  * 키 값이 루트보다 크면 오른쪽 서브트리에 대해서 탐색연산을 수행한다
* 트리의 높이만큼 시간이 걸림



## 힙(heap)

> 가장 큰 키 또는 가장 작은 키를 갖는 노드를 찾기 위해 만든 자료구조

* 완전 이진 트리면서 부모의 키 값이 항상 자식보다 큼/ 작음



### 값 삽입

* 삽입하고자 하는 값이 힙 조건에 안 맞는다면?

  * 왜? : 완전이진트리 구조를 유지하면서 값의 대소 비교도 만족해야함

* ```python
  def enq(n):
      global last
      last += 1
      tree[last] = n  # 완전이진트리 유지
      # 최대 힙 규칙 유지
      c = last
      p = c//2    # 완전이진트리에서 부모 정점 번호
      # 부모가 있고, 자식의 키 값이 더 크면
      while p >= 1 and tree[p] < tree[c]:
          tree[p], tree[c] = tree[c], tree[p]
          c = p
          p = c // 2
  ```



### 값 삭제

* 힙에서는 루트의 값만 삭제한다

* 루트의 값을 반환, 삭제 -> 마지막 노드의 값을 루트에 삽입, 마지막 노드 삭제 -> 위치 교환

* ```python
  def deq():  # 삭제과정 : 루트 삭제 -> 마지막 정점 값을 루트로 -> 교환 시작
      global last
      tmp = tree[1]   # 루트의 key
      tree[1] = tree[last]
      last -= 1       # 마지막 노드 삭제한 것과 동일 (인덱스 위치 바꿔서)
      # 최대 힙 규칙 유지
      p = 1
      c = p * 2   # 왼쪽 자식노드 번호
  
      while c <= last:    # 왼쪽 자식노드가 실재하면
          # 왼쪽, 오른쪽 중 어느 것과 교환할지 정하기
          if c+1 <= last and tree[c] < tree[c+1]: # 오른쪽도 실재하고 더 크다면
              c += 1                              # 오른쪽 선택
          # 교환과정
          if tree[p] < tree[c]:
              tree[p], tree[c] = tree[c], tree[p]
              p = c
              c = p * 2
          else:
              break
  
      return tmp
  ```

