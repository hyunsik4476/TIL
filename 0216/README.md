# APS_string

> 20220216

## ASCII

* 7비트 인코딩으로 128문자 표현
* 33개의 출력 불가능한 제어 문자들과 95개의 출력 가능한 문자로 이루어짐
* 서로다른 국가간/ 지역간 통신에 서로 다른 코드 사용으로 문제 발생



## 유니코드

* [공식 문서](https://home.unicode.org/)
* 다국어 처리를 위한 표준
* 2개, 혹은 4개의 바이트로 구성
  * 8 비트(-bit)는 1 바이트(Byte)
  * 메모리의 주소 단위는 바이트단위, 큰 숫자의 경우 여러 개의 바이트를 묶어서 읽음
  * 이 경우에 메모리에 저장하는 순서 방법론(big/ little-endian)

* 유니코드 인코딩
  * UTF-8 : 최소 비트 수 8-bit, 최대 32-bit(1 Byte * 4)
* #-\*- coding: utf-8-\*- : 파이썬 첫 줄에 인코딩 방식 명시(3.x~ 버전에선 생략 가능)



## 문자열

### 문자열의 분류

* fixed length/ variable length
* 자바/ 파이썬의 경우 문자열을 저장할 때 문자열의 앞에 그 정보를 저장하는 추가적 정보가 필요
  * Class pointer, Flags, Locks, ... , 'Char'
  * String 클래스를 사용해 가공/ 처리 가능



* C 언어의 문자열은 배열 형태로 구현된 응용 자료형
  * 배열의 끝에 Null 문자 `\0`이 들어가야함
  * 추가로 저장할 정보가 없으므로 더 적은 메모리를 차지함



* 숫자-문자 변환

* ```python
  def itoa(a):
      s = ''
      while a > 0:
          s = s + chr(ord('0') + a%10)
          a //= 10
      return s[::-1]
  
  def atoi(a):
      i = 0
      for x in s:
          i = i*10 + ord(x) - ord('0')
      return i
  ```

* 



## 패턴 매칭

### 고지식한 패턴 검색 알고리즘

* 인덱스 연산 연습의 일환으로 반드시 할 줄 알아야 함

* 본문 문자열을 처음부터 끝까지 순회하면서 패턴 내의 문자들을 일일이 비교

* ```python
  def BruteForce(p, t):
      i = 0
      j = 0
      while j < M and i < N:
          if t[i] != p[j]:
              i = i - j
              j = -1
          i = i + 1
          j = j + 1
      if j == M: return i-M
      else: return -1
  ```

* 최악의 경우 O(MN)의 시간 복잡도를 가짐





### 카프-라빈 알고리즘





### KMP알고리즘

* 패턴을 전처리해 배열 next[M]\(=lps)을 구해 다음 이동할 위치를 구해 잘못된 시작을 최소화함
* 패턴의 각 부분에 대해 매칭에 실패했을 때 돌아갈 곳의 인덱스를 저장하는 배열을 만듬
* 패턴에 반복되는 부분이 있을 경우 그러한 반복에 대한 비교횟수를 줄일 수 있음



* 구현

  * 패턴 문자에 대해서 위의 고지식한 검색과 유사하게 검색 시작

  * 패턴 문자 리스트에 대해서 각 자리에 자신 앞의 문자와 연속으로 일치하는 수 만큼 더해서 기록

  * ```python
    ex = ['a', 'b', 'c', 'd', 'a', 'b', 'c', 'e', 'f']
    lps = [-1 , 0 ,  0  , 0 ,  0 ,  1 ,  2 ,  3 ,  0 ,  0]
    # 마지막 0은 패턴을 찾은 경우 새롭게 시작할 비교 위치
    ```

  * ```python
    def kmp(t, p):
        N = len(t)
        M = len(p)    
        lps = [0]* (M+1)
        #전처리 과정 시작
        j = 0 # 일치한 개수 == 비교할 패턴 위치
        lps[0] = -1
        for i in range(1, M):
            lps[i] = j		# p[i] 이전에 일치한 개수
            if p[i] == p[j]:
                j += 1
            else:
                j = 0
        lps[M] = j
        #검색 시작
        i = 0
        j = 0
        while i < N and j <= M:
            if j == -1 or t[i] == p[j]: # 첫글자가 불일치하거나, 일치하면
                i += 1
                j += 1
            else:			# 불일치
                j = lps[j]
            if j == M:		# 패턴을 찾은 경우
                print(i-M, end = ' ')	# 패턴의 인덱스 출력
                j = lps[j] # 패턴을 찾고 난 뒤 남은 문자열을 체크할 때
    ```

  * 



### 보이어-무어 알고리즘

* 오른쪽에서 왼쪽으로 비교함
* 패턴의 끝 글자와 텍스트의 문자가 불일치하고, 해당 문자가 패턴 내에 없으면 
  단계가 패턴의 길이만큼 이동한다
* 패턴의 끝 글자와 텍스트의 문자가 불일치하고, 해당 문자가 패턴 내에 있으면 
  단계가 패턴에서 일치하는 문자의 위치만큼 이동한다
* 만약, 패턴 문자열이 rhitm 이라면
  * 문자열의 스킵 배열은 ['m': 0, 'h': 1, 't': 2, 'i': 3, 'r': 4, 다른 모든 문자: 5]
* 일반적으로 O(n)보다 시간이 덜 든다



### 호스풀(horspool) 알고리즘???



## 문자열 암호화

